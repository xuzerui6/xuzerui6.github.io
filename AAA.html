<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 手势交互粒子系统(xuzerui6)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI 覆盖层 */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }
        
        .status-badge {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 30px;
            color: #00ff88;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .dot { width: 8px; height: 8px; background: #00ff88; border-radius: 50%; box-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88; }
        .dot.inactive { background: #ff4444; box-shadow: 0 0 10px #ff4444; }

        /* 摄像头预览 */
        #video-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            transform: scaleX(-1);
            opacity: 0.5;
            z-index: 10;
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.3s;
        }
        #video-preview:hover { opacity: 1; }

        /* 全屏按钮 */
        #fullscreen-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #fullscreen-btn:hover { background: rgba(255,255,255,0.2); }

        .lil-gui { pointer-events: auto; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="status-badge">
            <div class="dot inactive" id="cam-status-dot"></div>
            <span id="cam-status-text">等待摄像头...</span>
        </div>
    </div>

    <video id="video-preview" playsinline></video>
    <div id="canvas-container"></div>
    <button id="fullscreen-btn">⛶ 全屏模式</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- 全局配置 ---
        const CONFIG = {
            particleCount: 40000, // 增加粒子数量
            particleSize: 0.15, 
            shape: 'heart',
            color: '#ff0066',
            autoRotate: true,
            
            // HSL 变量在 JS 中用于实时调整颜色
            baseColorHSL: { h: 0, s: 1, l: 0.5 },
        };

        // --- Three.js 初始化 ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setClearColor(0x000000); // 纯黑背景，确保发光效果
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;
        controls.enablePan = false;
        controls.minDistance = 10;
        controls.maxDistance = 80;

        // --- 核心数学部分：心形模型修正 ---
        
        function getShapeData(type, count) {
            const positions = new Float32Array(count * 3);
            const randomness = new Float32Array(count);
            
            for (let i = 0; i < count; i++) {
                let x, y, z;
                const i3 = i * 3;

                randomness[i] = Math.random();

                if (type === 'heart') {
                    // [最终心形修复] 基于参数方程的 3D 饱满心形
                    // 使用两个参数 (t, u) 来确保点云在体积内均匀分布
                    const t = Math.random() * 2 * Math.PI; // 0 to 2PI
                    const u = Math.random() * 2 * Math.PI; // 0 to 2PI
                    
                    // 主体形状
                    const rBase = 16 * Math.pow(Math.sin(t), 3);
                    const yBase = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    
                    // 引入 Z 轴厚度
                    const thickness = 6 * Math.cos(u) * Math.sqrt(Math.abs(Math.sin(t)));
                    
                    x = rBase * 0.8 + thickness * Math.cos(t); 
                    y = (yBase - 6) * 0.8 + thickness * Math.sin(t);
                    z = thickness * 0.5;
                    
                    // 确保心形居中且饱满
                    x *= 0.8;
                    y *= 0.8;
                    z *= 0.8;
                } 
                else if (type === 'flower') {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = 8 + 3 * Math.sin(5 * theta) * Math.sin(5 * phi);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.cos(phi);
                    z = r * Math.sin(phi) * Math.sin(theta);
                }
                else if (type === 'saturn') {
                    const rand = Math.random();
                    if (rand < 0.4) {
                        const r = 5 * Math.cbrt(Math.random()); 
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    } else {
                        const r = 7 + Math.random() * 8;
                        const theta = Math.random() * Math.PI * 2;
                        x = r * Math.cos(theta);
                        z = r * Math.sin(theta);
                        y = (Math.random() - 0.5) * 0.8;
                    }
                    const tilt = 0.4;
                    const tempY = y;
                    y = y * Math.cos(tilt) - z * Math.sin(tilt);
                    z = tempY * Math.sin(tilt) + z * Math.cos(tilt);
                }
                else if (type === 'spiral') {
                    const t = i / count; 
                    const angle = t * Math.PI * 20; 
                    const radius = 6;
                    x = radius * Math.cos(angle);
                    z = radius * Math.sin(angle);
                    y = (t - 0.5) * 25;
                    
                    if (i % 2 === 0) { x = -x; z = -z; }
                    x += (Math.random()-0.5)*1.5;
                    y += (Math.random()-0.5)*1.5;
                    z += (Math.random()-0.5)*1.5;
                }
                else if (type === 'galaxy') {
                    const armCount = 3;
                    const spin = i / count * armCount * Math.PI * 2;
                    const radius = Math.pow(Math.random(), 1.5) * 18; 
                    const armAngle = (i % armCount) / armCount * Math.PI * 2;
                    
                    x = radius * Math.cos(spin + armAngle);
                    z = radius * Math.sin(spin + armAngle);
                    y = (Math.random() - 0.5) * (radius * 0.2); 
                    if (radius < 3) y *= 3;
                }

                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
            }
            return { positions, randomness };
        }

        // 创建粒子纹理 (圆形渐变)
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)'); 
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)'); 
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = createParticleTexture();

        // 初始化几何体
        const geometry = new THREE.BufferGeometry();
        
        const initialData = getShapeData('heart', CONFIG.particleCount);
        geometry.setAttribute('position', new THREE.BufferAttribute(initialData.positions, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(initialData.randomness, 1));
        
        // **关键**：为每个粒子预留颜色缓冲区
        const colors = new Float32Array(CONFIG.particleCount * 3);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));


        const shapeCache = {
            'heart': initialData.positions,
            'flower': getShapeData('flower', CONFIG.particleCount).positions,
            'saturn': getShapeData('saturn', CONFIG.particleCount).positions,
            'spiral': getShapeData('spiral', CONFIG.particleCount).positions,
            'galaxy': getShapeData('galaxy', CONFIG.particleCount).positions,
        };

        // --- 材质 (回滚到 PointsMaterial) ---
        
        const material = new THREE.PointsMaterial({
            size: CONFIG.particleSize,
            sizeAttenuation: true,
            map: particleTexture, // 使用圆形纹理实现光晕感
            vertexColors: true,   // **关键：允许使用 geometry 里的颜色缓冲区**
            blending: THREE.AdditiveBlending, // **关键：叠加混合实现发光和拖尾效果**
            transparent: true,
            depthWrite: false,
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- 交互与动画逻辑 ---
        const currentPositions = new Float32Array(CONFIG.particleCount * 3);
        currentPositions.set(initialData.positions);
        
        let targetScale = 1.0;
        let currentScale = 1.0;
        let handDetected = false;
        
        const liveColor = new THREE.Color();
        const tempColor = new THREE.Color();

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            
            // 颜色实时计算 (基于 CONFIG.baseColorHSL)
            liveColor.setHSL(CONFIG.baseColorHSL.h, CONFIG.baseColorHSL.s, CONFIG.baseColorHSL.l);

            // 1. 手势缩放平滑过渡
            if (!handDetected) targetScale = 1.0;
            currentScale += (targetScale - currentScale) * 0.1;

            // 2. 粒子大小动态呼吸 (在 JS 中实时更新 size)
            const breathing = 1.0 + Math.sin(elapsedTime * 3.0) * 0.1;
            material.size = CONFIG.particleSize * breathing * currentScale;

            // 3. 形状变形与运动
            const targetPositions = shapeCache[CONFIG.shape];
            const positions = particleSystem.geometry.attributes.position.array;
            const colorsArray = particleSystem.geometry.attributes.color.array;
            const randomArray = particleSystem.geometry.attributes.aRandom.array;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                
                // --- 位置更新 (包含噪声运动) ---
                const noiseFactor = 0.05 + currentScale * 0.1; 
                const noiseX = Math.sin(elapsedTime * 0.5 + randomArray[i] * 10.0 + currentPositions[i3+2] * 0.1) * noiseFactor;
                const noiseY = Math.cos(elapsedTime * 0.5 + randomArray[i] * 10.0 + currentPositions[i3] * 0.1) * noiseFactor;
                const noiseZ = Math.sin(elapsedTime * 0.5 + randomArray[i] * 10.0 + currentPositions[i3+1] * 0.1) * noiseFactor;
                
                // CPU 上的平滑过渡
                currentPositions[i3]     += (targetPositions[i3] + noiseX - currentPositions[i3]) * 0.05;
                currentPositions[i3 + 1] += (targetPositions[i3 + 1] + noiseY - currentPositions[i3 + 1]) * 0.05;
                currentPositions[i3 + 2] += (targetPositions[i3 + 2] + noiseZ - currentPositions[i3 + 2]) * 0.05;

                // 应用手势缩放并赋值给 GPU
                positions[i3]     = currentPositions[i3] * currentScale;
                positions[i3 + 1] = currentPositions[i3 + 1] * currentScale;
                positions[i3 + 2] = currentPositions[i3 + 2] * currentScale;
                
                // --- 颜色更新 (实现闪烁和发光) ---
                // 颜色 = 基础颜色 * (亮度 + 随机闪烁)
                const flicker = 0.8 + 0.2 * randomArray[i] * Math.abs(Math.sin(elapsedTime * 5 + randomArray[i] * 10));
                
                // 将 HSL 基础色乘以闪烁因子 (RGB 空间)
                tempColor.copy(liveColor);
                tempColor.multiplyScalar(flicker);

                colorsArray[i3]     = tempColor.r;
                colorsArray[i3 + 1] = tempColor.g;
                colorsArray[i3 + 2] = tempColor.b;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true; // 每次更新颜色

            if(CONFIG.autoRotate) {
                controls.update();
            }

            renderer.render(scene, camera);
        }
        
        animate();

        // --- UI 设置 (Lil-GUI) ---
        const gui = new GUI({ title: '控制面板' });
        gui.add(CONFIG, 'shape', ['heart', 'flower', 'saturn', 'spiral', 'galaxy']).name('模型形状');

        gui.addColor(CONFIG, 'color')
           .name('基础颜色')
           .onChange((val) => {
               const c = new THREE.Color(val);
               c.getHSL(CONFIG.baseColorHSL);
           });
        
        gui.add(CONFIG, 'particleSize', 0.05, 0.5) 
           .name('粒子大小系数')
           .onChange((val) => CONFIG.particleSize = val);

        gui.add(CONFIG, 'autoRotate').name('自动旋转');

        // --- MediaPipe Hands 集成 ---
        const videoElement = document.getElementById('video-preview');
        const statusDot = document.getElementById('cam-status-dot');
        const statusText = document.getElementById('cam-status-text');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                if(!handDetected) {
                    handDetected = true;
                    statusDot.classList.remove('inactive');
                    statusText.innerText = "手势已捕捉";
                }

                const landmarks = results.multiHandLandmarks[0];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // 映射距离到缩放比例
                const clampedDist = Math.max(0.02, Math.min(distance, 0.4));
                targetScale = 0.4 + ((clampedDist - 0.02) / 0.38) * 2.1; 

                // 映射距离到颜色亮度 (L)
                const targetL = 0.3 + ((clampedDist - 0.02) / 0.38) * 0.6;
                // 平滑更新 HSL 的 L
                CONFIG.baseColorHSL.l += (targetL - CONFIG.baseColorHSL.l) * 0.2; 

            } else {
                if(handDetected) {
                    handDetected = false;
                    statusDot.classList.add('inactive');
                    statusText.innerText = "未检测到手部";
                    // 恢复基础亮度
                    CONFIG.baseColorHSL.l += (0.5 - CONFIG.baseColorHSL.l) * 0.2;
                }
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        cameraUtils.start()
            .then(() => statusText.innerText = "摄像头已启动，请伸手...")
            .catch(err => {
                console.error(err);
                statusText.innerText = "摄像头访问失败";
            });

        // --- 窗口调整 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                document.getElementById('fullscreen-btn').innerText = "退出全屏";
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                    document.getElementById('fullscreen-btn').innerText = "⛶ 全屏模式";
                }
            }
        });

    </script>
</body>
</html>